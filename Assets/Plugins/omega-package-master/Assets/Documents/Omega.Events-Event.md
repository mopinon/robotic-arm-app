# Определение события 

Первым делом нужно описать само событие, его название, перечень параметров и атрибутов события.
В качестве идентификатора события может выступать любой тип

### Создание нового события
Чтобы описать новое событие достаточно просто создать новый тип, например так
```csharp
class SomeType { }
```
Тип `SomeType` уже можно использовать в качестве идентификатора события, однако настоятельно рекомендуется использовать окончание "Event" в названии типа, описывающие событие. Например SomeEvent, окончание дает понять что тип является описанием события, что улучшает восприятие кода.

### Модификаторы события
С помощью атрибута `EventCoverageAttribute` можно связать событие со сценой, то есть связать всех обработчиков события, на котором весит этот атрибут, со сценой. Таким образом при переключении сцены, все обработчики принадлежащие предыдущий сцене не будут обрабатывается на новой. 
```csharp
[EventCoverage(EventCoverage.Scene)]
class SomeEvent { }
```
В атрибуте также сожно задать значение `EventCoverage.Global`, который не связывает обработчиков события со сценой. То есть все обработчики будут существовать всегда, пока кто-то не отпишет обработчика от события (с помощью метода `RemoveHandler` в `EventAggregator`).
Если на типе, который определяет событие, нет ни атрибута `SceneEvent` ни атрибута `GlobalEvent`, то событие будет глобальным по умолчанию.
```csharp
[EventCoverage(EventCoverage.Global)]
class FirstEvent { }
class SecondEvent { } // Атрибутов нет, но событие все равно будет глобальным
```
Несмотря на то, что событие без атрибутов является глобальным по умолчанию, то, в случае необходимости такого поведения, все же, рекомендуется указывать это явно (с помощью атрибута `EventCoverage(EventCoverage.Global)`) дабы улучшить восприятие кода и избежать проблем если в будущих версиях поведение по умолчанию будет изменено 

### Выбор между `class` и `struct`
Перед созданием типа, который будет описывать событие, важно сделать выбор между классом и структурой, от этого может зависеть поведение самого события, читаемость кода, а также, в некоторых случаях, и производительность.
#### Ситуации когда лучше использовать `class` 
- Событие не содержит каких-либо параметров вообще 
- Размер аналогичной по составу полей (параметров) структуры слишком велик
- Определение события должно быть наследовано от другого класса
- Параметр события должен быть мутабельным _(не рекомендуется)_

#### Ситуации когда лучше использовать `struct`
- Событие не содержит большого кол-ва параметров. Допустимый размер структуры - **64 байта**. Это например, шестнадцать полей типа `float` или восемь поля типа `double` или восемь поля типа `string` _(для 64-разрядных систем)_
- Аргумент должен копироваться для каждого из обработчиков (дабы гарантировано избежать изменение состояния аргумента во время оповещения обработчиков о событии)
- Событие вызывается довольно часто и/или не будет большого кол-ва обработчиков этого события . Структуры позволяют не аллоцировать память на куче и не влиять на работу GC, что позитивно скажется на производительности

Несмотря на то, что кол-во ситуаций, когда лучше использовать `class` больше чем для `struct`, рекомендуется отдавать предпочтение именно структурам

### Общие рекомендации
1. Каждый тип, который описывает событие, рекомендуется сопровождать окончанием "Event"
2. Все события рекомендуется определять в отдельном namespace`се и с помощью их делить события по категориям (_*.Events.Analytics_ _*.Events.Player_ _*.Events.Server_ _*.Events.UI_ и тд)
3. Использовать `struct`/`class` в зависимости от ситуации
4. Не допускать изменения состояния аргумента события, во время оповещения обработчиков этого события _(актуально только когда определение события является классом)_. 
5. Использовать иммутабельные структуры данных
6. Использовать атрибут `EventCoverageAttribute`
7. Реализовывать свойства и методы внутри определения события для облегчения работы с аргументом события 
8. Использовать говорящие имена для событий

### Пример правильного определения события
```csharp
namespace MyProject.Events.Game // Разделение событий по namespace`ам
{
    [EventCoverage(EventCoverage.Scene)]// Явное указание типа события
    // Использование структуры и ключевого слова readonly 
    public readonly struct PickupBonusEvent
    {
        // Не большое кол-во полей
        // Использование ключевого слова readonly 
        public readonly Bonus BonusInstance;
        // Использование свойств которые облегчают работу с аргументом события
        public string BonusTitle => BonusInstance.title;
        
        public PickupBonusEvent(Bonus bonus)
        {
            BonusInstance = bonus;
        }
    }
}
```

### Пример плохого определения события
```csharp
// Событие лежит в глобальном namespace`е
// Отсутствие атрибута "EventCoverage"
// Плохое, не говорящие название, лучше было бы использовать "UserWatchedAdsEvent"
// Не оправданное использование класса
public class UserAds
{
    // Не используется иммутабельный подход, состояние аргумента события можно изменить
    public AdsType AdsType;
    public AdsProvider AdsProvider;
    public AdsHandle AdsHandle;
}
```